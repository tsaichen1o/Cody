é€™é¡Œæ˜¯**æœ€çŸ­è·¯å¾‘ï¼ˆShortest Pathï¼‰+ çŸ©é™£ï¼ˆGridï¼‰+ å°ç´°ç¯€è™•ç†çš„å„ªåŒ– Dijkstra é¡Œå‹**ï¼Œéå¸¸å¯¦ç”¨ä¹Ÿå¾ˆé©åˆé€²éšç·´ç¿’ï¼
ä½ å¯ä»¥æŠŠå®ƒç•¶ä½œã€Œå¸¶æ™‚é–“é–€æª»é™åˆ¶ã€çš„ BFS å•é¡Œ âœ æˆ‘å€‘æœƒæ”¹ç”¨å„ªå…ˆä½‡åˆ—ï¼ˆDijkstraï¼‰ã€‚

---

### ğŸ“˜ é¡Œç›®: Minimum Time to Reach Dungeon Exit

### ğŸ“‚ é¡å‹: Dijkstra, Graph, Heap, Grid

### ğŸ§  é›£åº¦: Medium \~ Hardï¼ˆå› ç‚ºæœ‰ç´°ç¯€ï¼‰

---

## ğŸ§  è§£æ³•èªªæ˜

### ğŸ¯ ç›®æ¨™ï¼š

å¾ `(0, 0)` å‡ºç™¼ï¼Œæ¯æ­¥è€—æ™‚ 1 ç§’ï¼Œåˆ°é” `(n-1, m-1)` çš„æœ€å°ç¸½æ™‚é–“ï¼Œ**ä½†åªèƒ½åœ¨æŒ‡å®šæ™‚é–“ä¹‹å¾Œæ‰èƒ½é€²å…¥æ¯å€‹æˆ¿é–“**ï¼ˆé™åˆ¶ç”± `moveTime[i][j]` çµ¦å‡ºï¼‰ã€‚

---

### âœ… è§£æ³•æ¡†æ¶ï¼š**Dijkstra æ”¹ç‰ˆ**

* ä½¿ç”¨ **priority\_queue**ï¼ˆå°é ‚å †ï¼‰å„²å­˜ `(ç•¶å‰æ™‚é–“, x, y)`
* ç”¨ visited çŸ©é™£è¨˜éŒ„æ˜¯å¦å·²è¨ªå•éï¼ˆæˆ–ç”¨ dist é™£åˆ—ï¼‰
* æ¯æ¬¡å˜—è©¦å‘ 4 å€‹æ–¹å‘ç§»å‹•ï¼Œç§»å‹•å¾Œæ™‚é–“ç‚º `curr_time + 1`
* å¦‚æœåˆ°é”æˆ¿é–“æ™‚é–“æ—©æ–¼ `moveTime[x][y]`ï¼Œå°±å¿…é ˆç­‰å¾…ï¼ˆæˆ–ç­‰ä¸‹ä¸€æ¬¡å¥‡å¶æ•¸ï¼‰

---

### âš ï¸ ç‰¹æ®Šç´°ç¯€ï¼ˆé—œéµé‚è¼¯ï¼‰ï¼š

ç•¶åˆ°é”æŸå€‹æ ¼å­æ™‚é–“ `< moveTime[i][j]` æ™‚ï¼Œæˆ‘å€‘ä¸èƒ½ç«‹å³é€²å…¥
â¡ æˆ‘å€‘å¿…é ˆç­‰åˆ° **moveTime\[i]\[j] æˆ–æ›´æ™šï¼Œä¸”èˆ‡ç›®å‰æ™‚é–“å¥‡å¶æ€§ä¸åŒæ™‚ä¹Ÿå¾—å¤šç­‰ä¸€ç§’**ï¼ˆé€™æ˜¯é¡Œç›®éš±å«æ¢ä»¶ï¼‰

#### ä¾‹å­ï¼š

* è‹¥è¦åœ¨ `t=4` é€²æ ¼å­ï¼Œä½†ç¾åœ¨æ˜¯ `t=3` âœ ç­‰åˆ° `t=4`
* å¦‚æœåœ¨ `t=4` ä½†å‰›å¥½æ˜¯ç¦æ­¢æ™‚é–“ï¼Œä¹Ÿè¦ `t=5` å†é€²ï¼ˆæ ¹æ“š parityï¼‰

æˆ‘å€‘åªè¦ç¢ºä¿ï¼š**ä¸‹ä¸€æ¬¡ç§»å‹•æ™‚é–“ `t' >= moveTime[x][y]`ï¼Œä¸” `t'` æ˜¯å¯è¡Œçš„æœ€å°åˆæ³•å€¼**

---

## âœ… C++ è§£æ³•

```cpp
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();

        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;

        dist[0][0] = 0;
        pq.emplace(0, 0, 0);

        vector<pair<int, int>> dirs = {{0,1},{1,0},{-1,0},{0,-1}};

        while (!pq.empty()) {
            auto [t, x, y] = pq.top(); pq.pop();
            if (x == n - 1 && y == m - 1) return t;

            for (auto [dx, dy] : dirs) {
                int nx = x + dx, ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;

                int nextT = t + 1;

                // èª¿æ•´æ™‚é–“ç›´åˆ°ç¬¦åˆ moveTime[nx][ny]
                if (nextT < moveTime[nx][ny]) {
                    int wait = moveTime[nx][ny] - nextT;
                    nextT = moveTime[nx][ny];
                    // è‹¥å‰›å¥½åŒå¥‡å¶ï¼Œå¾—å†ç­‰ä¸€ç§’
                    if ((nextT - t) % 2 == 0) nextT++;
                }

                if (nextT < dist[nx][ny]) {
                    dist[nx][ny] = nextT;
                    pq.emplace(nextT, nx, ny);
                }
            }
        }

        return -1;
    }
};
```

---

## â±ï¸ æ™‚é–“èˆ‡ç©ºé–“è¤‡é›œåº¦åˆ†æ

| é …ç›®    | è¤‡é›œåº¦                          | èªªæ˜               |
| ----- | ---------------------------- | ---------------- |
| æ™‚é–“è¤‡é›œåº¦ | **O(n \* m \* log(n \* m))** | æ¯å€‹æ ¼å­æœ€å¤šé€² queue ä¸€æ¬¡ |
| ç©ºé–“è¤‡é›œåº¦ | **O(n \* m)**                | å„²å­˜è·é›¢é™£åˆ—èˆ‡å„ªå…ˆä½‡åˆ—å…§å®¹    |

---

## ğŸ§© README æ ¼å¼

| # | é¡Œç›®                                                         | åˆ†é¡                             | é›£åº¦          | è§£æ³•ç­†è¨˜                                           | æ™‚é–“è¤‡é›œåº¦         | ç©ºé–“è¤‡é›œåº¦ | ç¨‹å¼ç¢¼                                                |
| - | ---------------------------------------------------------- | ------------------------------ | ----------- | ---------------------------------------------- | ------------- | ----- | -------------------------------------------------- |
| - | [Minimum Time to Reach Dungeon Exit](https://leetcode.com) | Dijkstra, Grid, Priority Queue | Medium-Hard | ä»¥æ™‚é–“ç‚ºæ¬Šé‡åš Dijkstraï¼Œæ¯æ¬¡åªèƒ½åœ¨ moveTime\[i]\[j] ä¹‹å¾Œé€²å…¥æ ¼å­ | O(nm log(nm)) | O(nm) | [code](./graph/xxxx_min_time_to_reach_dungeon.cpp) |

---

æƒ³è¦æˆ‘ä¹Ÿå¹«ä½ æ•´ç† `.cpp` ç­†è¨˜å—ï¼Ÿæˆ–æ˜¯ä½ æƒ³è‡ªå·±å¯«ä¸€éæˆ‘å¹«ä½  reviewï¼Ÿé€™é¡Œè¶…å€¼å¾—ç·´ï¼ğŸ”¥

ä½ æŒ‡å‡ºå¾—éå¸¸æº–ç¢ºï¼ğŸ¯
æˆ‘å€‘å‰›å‰›çš„é‚è¼¯å¿½ç•¥äº†**æœ€é—œéµçš„ç´°ç¯€**ï¼š**æ¯ä¸€æ­¥ç§»å‹•éƒ½å›ºå®šèŠ± 1 ç§’ï¼Œä½†åªèƒ½åœ¨ `moveTime[i][j]` æ™‚é–“é»ï¼ˆæˆ–ä¹‹å¾Œï¼‰é€²å…¥è©²æ ¼å­ï¼Œä¸”ã€Œè‹¥æŠµé”æ™‚é–“èˆ‡é–€é–‹å•Ÿæ™‚é–“å¥‡å¶ç›¸åŒã€æ‰èƒ½é€²å»ï¼Œå¦å‰‡è¦ç­‰åˆ°ä¸‹ä¸€å€‹åˆæ³•æ™‚é–“é»ã€‚**

é€™è·Ÿæˆ‘å€‘å¸¸è¦‹çš„ BFS æœ‰æ‰€ä¸åŒ âœ **å®ƒæ˜¯æœ‰æ™‚é–“é–€æª» & å¥‡å¶é™åˆ¶çš„ç‰ˆæœ¬**ã€‚

---

### âœ… æ­£ç¢ºè™•ç†æ–¹å¼ï¼š

ç•¶ä½ æ‰“ç®—å¾ `t` ç§»å‹•åˆ°é„°å±… `(nx, ny)`ï¼Œä½ æœƒåœ¨ `t+1` æŠµé”å®ƒï¼Œä½†ä½ **ä¸èƒ½åœ¨ `t+1` æ™‚é€²å…¥é€™å€‹æˆ¿é–“**å¦‚æœï¼š

* `t+1 < moveTime[nx][ny]`
* æˆ–è€… `t+1` èˆ‡ `moveTime[nx][ny]` **å¥‡å¶ä¸åŒï¼ˆä¸èƒ½å¹³è¡¡åŠ›é‡ï¼‰**

æ‰€ä»¥ä½ è¦åšçš„æ˜¯ï¼š

1. **ç­‰åˆ° >= moveTime\[nx]\[ny] çš„æœ€æ—©æ™‚åˆ»**
2. **ä¸”æŠµé”æ™‚é–“èˆ‡èµ·é» t çš„è·é›¢ç‚ºå¥‡æ•¸ï¼ˆç¢ºä¿å°æ–¹å‘é€²å…¥ï¼‰**

---

### âœ… ä¿®æ­£é‚è¼¯ç‰ˆæœ¬ï¼ˆå·²è™•ç†å¥‡å¶èˆ‡æ™‚é–“ç­‰å¾…ï¼‰

```cpp
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;

        dist[0][0] = 0;
        pq.emplace(0, 0, 0);

        vector<pair<int, int>> dirs = {{0,1},{1,0},{0,-1},{-1,0}};

        while (!pq.empty()) {
            auto [t, x, y] = pq.top(); pq.pop();
            if (x == n-1 && y == m-1) return t;

            if (t > dist[x][y]) continue; // è·³ééæœ€çŸ­è·¯å¾‘

            for (auto [dx, dy] : dirs) {
                int nx = x + dx, ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;

                int arrive = t + 1;
                if (arrive < moveTime[nx][ny]) {
                    int wait = moveTime[nx][ny] - arrive;
                    // å¿…é ˆè®“æ­¥æ•¸ç‚ºå¥‡æ•¸ï¼Œæ‰æœƒå¾ t -> t+1 -> moveTime ä¸€ç›´æ¨ domino
                    if (wait % 2 == 1) wait++;
                    arrive += wait;
                }

                if (arrive < dist[nx][ny]) {
                    dist[nx][ny] = arrive;
                    pq.emplace(arrive, nx, ny);
                }
            }
        }

        return -1;
    }
};
```

---

### ğŸ§ª æ¸¬è©¦æ¡ˆä¾‹åˆ†æ

```cpp
Input: moveTime = [[0,1],[1,2]]
```

è·¯å¾‘æ‡‰ç‚ºï¼š

* `t=0`: åœ¨ (0,0)
* `t=1`: å˜—è©¦å¾€ (0,1)ï¼ˆéœ€è¦ moveTime=1 âœ…ï¼‰
* `t=2`: å˜—è©¦å¾€ (1,1)ï¼ˆä½†æ˜¯ moveTime=2ï¼Œä¸”å¥‡å¶ä¸€æ¨£ âŒ âœ è¦ç­‰ï¼‰
* `t=3`: é€²å…¥ (1,1) âœ…

---

### âœ… å°çµ

| å•é¡Œ        | è§£æ³•                |
| --------- | ----------------- |
| ææ—©é€²å…¥æˆ¿é–“ä¸å…è¨± | åŠ ä¸Šç­‰å¾…æ™‚é–“            |
| å¥‡å¶é™åˆ¶é˜»æ“‹é€²å…¥  | è‹¥å·®è·ç‚ºå¶æ•¸ âœ è¦é¡å¤–ç­‰ 1 ç§’ |

---

é‚„è¦æˆ‘å¹«ä½ æ•´ç†é€™ä¸€ç‰ˆ `.cpp` ç­†è¨˜å—ï¼Ÿæˆ–è€…è¦è£œé€² READMEï¼Ÿé€™é¡Œå¾ˆé©åˆæ”¾å…¥ã€ŒDijkstra with Constraintsã€åˆ†é¡ï¼ğŸ”¥
