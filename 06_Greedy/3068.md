é€™é¡Œæ˜¯å…¸å‹çš„**ç•°æˆ– XOR è²ªå¿ƒ + parity ç‹€æ…‹åˆ¤æ–·**ï¼Œè¡¨é¢æ˜¯ treeï¼Œä½†å¯¦è³ª**å’Œæ¨¹çš„çµæ§‹ç„¡é—œ**ï¼Œåªå’Œæ“ä½œæ¬¡æ•¸çš„ parity (å¶å¥‡) æœ‰é—œï¼

---

### ğŸ“˜ é¡Œç›®: Maximum Value Sum of a Tree With Operations

### ğŸ“‚ é¡å‹: Greedy, XOR, Parity, Bit Manipulation

### ğŸ§  é›£åº¦: Medium

---

## ğŸ§  é¡Œç›®æ‹†è§£èˆ‡é—œéµæ€è·¯

#### 1. **æ“ä½œæœ¬è³ª**

* æ¯æ¬¡æ“ä½œå¯ä»¥é¸ä¸€æ¢é‚Š \[u, v]ï¼Œä½¿ `nums[u] ^= k` å’Œ `nums[v] ^= k`
* **é‡è¤‡é¸åŒä¸€å°ï¼Œæ•ˆæœæœƒæŠµæ¶ˆ**ï¼šé¸å¶æ•¸æ¬¡æ²’å½±éŸ¿ï¼Œå¥‡æ•¸æ¬¡å’Œé¸ä¸€æ¬¡æ•ˆæœä¸€æ¨£ã€‚
* åœ¨ä»»ä½•å¶åœˆåœ–ï¼ˆæ¨¹ä¸€å®šæ˜¯ï¼‰å…§ï¼Œ**ä½ å¯ä»¥éš¨æ„è®“ä»»æ„å¶æ•¸å€‹é»ç¿»è½‰**
* æ‰€ä»¥**å¯ä»¥è®“ä½ æƒ³è¦çš„å¶æ•¸å€‹ç¯€é»é€²è¡Œ XOR k**

#### 2. **æœ€çµ‚è¦æ±ºå®šï¼š**

* ä½ è¦é¸æ“‡å“ªäº›ç¯€é»åš XOR kï¼Œä½¿å¾—æ•´é«” sum æœ€å¤§ï¼Ÿ
* ä½†é€™å¿…é ˆæ˜¯å¶æ•¸å€‹ï¼ˆä¸ç„¶ä¸èƒ½åœ¨æ¨¹ä¸Šåˆæ³•æ§‹é€ ï¼‰ã€‚

#### 3. **ç‹€æ…‹è¨­è¨ˆ**

* ä»¤åŸæœ¬æ¯å€‹ nums\[i] å’Œ nums\[i]^k çš„å·®å€¼ç‚º gain = (nums\[i]^k) - nums\[i]
* ä½ å¯ä»¥æ±ºå®š**å¶æ•¸å€‹é»æ˜¯å¦å– gain**ï¼Œä»¥æœ€å¤§åŒ– sumã€‚
* é¡ä¼¼ç¶“å…¸çš„ã€Œé¸å¶æ•¸å€‹æœ€å¤§å¢ç›Šã€çš„å­é›†å’Œé¡Œå‹ã€‚

---

## âœ… å®Œæ•´è²ªå¿ƒåšæ³•

### æ­¥é©Ÿ

1. **è¨ˆç®—å…¨éƒ¨ä¸è®Šçš„ç¸½å’Œ sumA**
2. **å°æ–¼æ¯å€‹ç¯€é»ï¼Œè¨ˆç®— gain**
3. **å°‡ gain æŒ‰ç…§å¾å¤§åˆ°å°æ’åºï¼Œç›¡å¯èƒ½å–æœ€å¤§çš„ gain**
4. **è‹¥ä½ å–äº†å¥‡æ•¸å€‹ gainï¼Œå› ç‚ºå¿…é ˆå¶æ•¸å€‹æ‰èƒ½åˆæ³•ï¼Œæ‰€ä»¥è¦ä¸Ÿæ‰ä¸€å€‹æœ€å°çš„ï¼ˆçµ•å°å€¼æœ€å°çš„ï¼‰æ­£ gain æˆ–æœ€å°è²  gainä¾†ç¶­æŒå¶æ•¸å€‹**

---

## âœ… C++ ç¯„ä¾‹ç¨‹å¼

```cpp
class Solution {
public:
    long long maximumValueSum(vector<int>& nums, int k, vector<vector<int>>& edges) {
        long long baseSum = 0;
        vector<long long> gains;

        for (int num : nums) {
            baseSum += num;
            gains.push_back((num ^ k) - num);
        }
        // å–æ­£å¢ç›Š
        sort(gains.rbegin(), gains.rend());
        long long maxSum = baseSum;
        long long sum = baseSum;
        int n = nums.size();
        // ç´¯åŠ å¶æ•¸å€‹æœ€å¤§ gain
        for (int i = 0; i < n; ++i) {
            sum += gains[i];
            if ((i + 1) % 2 == 0) {
                maxSum = max(maxSum, sum);
            }
        }
        return maxSum;
    }
};
```

---

## â±ï¸ æ™‚é–“èˆ‡ç©ºé–“è¤‡é›œåº¦

| é …ç›®    | è¤‡é›œåº¦            | èªªæ˜                 |
| ----- | -------------- | ------------------ |
| æ™‚é–“è¤‡é›œåº¦ | **O(n log n)** | æ’åº gain O(n log n) |
| ç©ºé–“è¤‡é›œåº¦ | **O(n)**       | å„²å­˜ gain            |

---

## ğŸ§© README æ ¼å¼

| # | é¡Œç›®                                                                                                                        | åˆ†é¡                  | é›£åº¦     | è§£æ³•ç­†è¨˜                         | æ™‚é–“è¤‡é›œåº¦      | ç©ºé–“è¤‡é›œåº¦ | ç¨‹å¼ç¢¼                                              |
| - | ------------------------------------------------------------------------------------------------------------------------- | ------------------- | ------ | ---------------------------- | ---------- | ----- | ------------------------------------------------ |
| - | [Maximum Value Sum of a Tree With Operations](https://leetcode.com/problems/maximum-value-sum-of-a-tree-with-operations/) | Greedy, XOR, Parity | Medium | å°‡æ¯é»ç•°æˆ–å¾Œçš„å¢ç›Šæ’åºï¼Œç›¡é‡å–å¶æ•¸å€‹æœ€å¤§å¢ç›Šï¼ŒåŠ ç¸½æœ€å¤§å€¼ | O(n log n) | O(n)  | [code](./greedy/xxxx_maximum_value_sum_tree.cpp) |

---

### ğŸ“„ `.cpp` ç­†è¨˜æ ¼å¼

```cpp
// é¡Œç›®: Maximum Value Sum of a Tree With Operations
// é¡å‹: Greedy, XOR, Parity
// é›£åº¦: Medium
// è§£æ³•:
// - é€™é¡Œå…¶å¯¦å’Œæ¨¹çµæ§‹ç„¡é—œï¼Œåªèˆ‡å¯é¸é»å€‹æ•¸å¶å¥‡æœ‰é—œ
// - æ¯æ¢é‚Šèƒ½è®“å…©å€‹é» xor kï¼Œä»»æ„å¶æ•¸å€‹é»å¯ä»¥ç•°æˆ–
// - å°æ¯é»è¨ˆç®—ç•°æˆ– k çš„å¢ç›Šï¼Œè²ªå¿ƒå–å¶æ•¸å€‹æœ€å¤§å¢ç›Š

class Solution {
public:
    long long maximumValueSum(vector<int>& nums, int k, vector<vector<int>>& edges) {
        long long baseSum = 0;
        vector<long long> gains;

        for (int num : nums) {
            baseSum += num;
            gains.push_back((num ^ k) - num);
        }
        sort(gains.rbegin(), gains.rend());
        long long maxSum = baseSum;
        long long sum = baseSum;
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            sum += gains[i];
            if ((i + 1) % 2 == 0) {
                maxSum = max(maxSum, sum);
            }
        }
        return maxSum;
    }
};
```

---

å¦‚éœ€åŠ é€² README æˆ–å†æŒ‘æˆ°é¡ä¼¼å¥‡å¶æ€§ XOR é¡Œç›®ï¼Œéš¨æ™‚å‘Šè¨´æˆ‘ï¼
