é€™é¡Œéå¸¸ç¶“å…¸ï¼Œçµåˆäº† **prefix sum + æ•¸å­¸æ¨å° + hash map çµ±è¨ˆé »ç‡**ï¼Œ  
æˆ‘ä¾†å¹«ä½ æ•´ç†æˆæ¸…æ¥šçš„çµæ§‹ï¼Œä¸¦ä¸”é™„ä¸Šæ™‚é–“èˆ‡ç©ºé–“è¤‡é›œåº¦åˆ†æã€‚

---

### ğŸ“˜ é¡Œç›®: Count Interesting Subarrays  
### ğŸ“‚ é¡å‹: Prefix Sum, HashMap, Math  
### ğŸ§  é›£åº¦: Medium  
---

## ğŸ§  è§£æ³•èªªæ˜

### ğŸ” Step-by-Step æ€è·¯ï¼š

1. **è¨ˆç®— prefix countï¼š**  
   - å®šç¾© `count[i]` ç‚ºã€Œå‰ i å€‹å…ƒç´ ä¸­æ»¿è¶³ `nums[i] % modulo == k` çš„æ•¸é‡ã€ã€‚
   - åˆå§‹åŒ– `count[0] = 0`ã€‚

2. **æ¨å°æ¢ä»¶ï¼š**  
   - æƒ³æ‰¾æ‰€æœ‰ `j < i` æ»¿è¶³ï¼š
     ```
     (count[i] - count[j]) % modulo == k
     ```
   - é€™å¯ä»¥è®Šå½¢ç‚ºï¼š
     ```
     count[j] % modulo == (count[i] + modulo - k) % modulo
     ```

3. **ä½¿ç”¨ HashMap å„²å­˜å‡ºç¾éçš„ prefix mod çµæœï¼š**  
   - `mp[x]` è¡¨ç¤º prefix mod ç‚º `x` çš„å‡ºç¾æ¬¡æ•¸ã€‚
   - æ¯æ¬¡åˆ°ç¬¬ `i` ä½æ™‚ï¼Œçµ±è¨ˆ `(count[i] + modulo - k) % modulo` å‡ºç¾å¹¾æ¬¡ï¼Œå°±èƒ½å¾—çŸ¥å¤šå°‘å€‹ç¬¦åˆæ¢ä»¶çš„å­é™£åˆ—ã€‚
   - æœ€å¾Œæ›´æ–° `mp[count[i] % modulo]++`ã€‚

---

## âœ… C++ å®Œæ•´è§£æ³•ï¼š

```cpp
class Solution {
public:
    long long countInterestingSubarrays(vector<int>& nums, int modulo, int k) {
        unordered_map<int, long long> mp;
        mp[0] = 1; // base case: prefix count ç‚º 0 æ™‚ä¹Ÿè¦ç®—
        
        long long ans = 0;
        int cnt = 0;
        
        for (int num : nums) {
            if (num % modulo == k) {
                cnt++;
            }
            
            int need = (cnt + modulo - k) % modulo;
            if (mp.count(need)) {
                ans += mp[need];
            }
            
            mp[cnt % modulo]++;
        }
        
        return ans;
    }
};
```

---

## â±ï¸ æ™‚é–“èˆ‡ç©ºé–“è¤‡é›œåº¦åˆ†æ

| é …ç›® | è¤‡é›œåº¦ | èªªæ˜ |
|:---|:---|:---|
| æ™‚é–“è¤‡é›œåº¦ | **O(n)** | å–®æ¬¡è¿´åœˆè™•ç†æ¯å€‹å…ƒç´ ï¼Œhash map æŸ¥è©¢èˆ‡æ›´æ–°ç‚º O(1) å¹³å‡ |
| ç©ºé–“è¤‡é›œåº¦ | **O(modulo)** | HashMap `mp` æœ€å¤šå„²å­˜ `modulo` ç¨®ä¸åŒçš„é¤˜æ•¸ |

---

## ğŸ§© README æ ¼å¼ï¼š

| # | é¡Œç›® | åˆ†é¡ | é›£åº¦ | è§£æ³•ç­†è¨˜ | æ™‚é–“è¤‡é›œåº¦ | ç©ºé–“è¤‡é›œåº¦ | ç¨‹å¼ç¢¼ |
|---|------|------|------|-----------|--------------|--------------|--------|
| - | [Count Interesting Subarrays](https://leetcode.com/problems/count-the-number-of-interesting-subarrays/) | Prefix Sum, HashMap, Math | Medium | è¨˜éŒ„ prefix count modï¼Œè½‰åŒ–æ¢ä»¶ç‚º hash æŸ¥è©¢ (cnt + mod - k) % modï¼Œçµ±è¨ˆå­é™£åˆ—æ•¸é‡ | O(n) | O(modulo) | [code](./prefix_sum/xxxx_count_interesting_subarrays.cpp) |

---

## ğŸ“„ `.cpp` ç­†è¨˜æ ¼å¼

```cpp
// é¡Œç›®: Count Interesting Subarrays
// é¡å‹: Prefix Sum, HashMap, Math
// é›£åº¦: Medium
// è§£æ³•:
// - å®šç¾© prefix countï¼šcntï¼Œä»£è¡¨å‰é¢å¤šå°‘å€‹å…ƒç´ ç¬¦åˆ nums[i] % modulo == kã€‚
// - ç›®æ¨™æ¢ä»¶æ˜¯ (cnt[i] - cnt[j]) % modulo == kï¼Œæ¨å°æˆ cnt[j] % modulo == (cnt[i] + modulo - k) % moduloã€‚
// - ä½¿ç”¨ hash map çµ±è¨ˆæ¯ç¨® prefix mod å‡ºç¾æ¬¡æ•¸ã€‚
// - æ¯æ¬¡çµ±è¨ˆæ™‚ï¼ŒåŠ ä¸Šç¬¦åˆæ¢ä»¶çš„éå» prefix æ•¸é‡ã€‚

class Solution {
public:
    long long countInterestingSubarrays(vector<int>& nums, int modulo, int k) {
        unordered_map<int, long long> mp;
        mp[0] = 1;
        
        long long ans = 0;
        int cnt = 0;
        
        for (int num : nums) {
            if (num % modulo == k) {
                cnt++;
            }
            
            int need = (cnt + modulo - k) % modulo;
            if (mp.count(need)) {
                ans += mp[need];
            }
            
            mp[cnt % modulo]++;
        }
        
        return ans;
    }
};
```

---

è¦ä¸è¦é †ä¾¿ä¸€èµ·å¹«ä½ æŠŠé€™é¡ŒåŠ é€² README çš„æ–°ä¸€è¡Œï¼Ÿâœï¸  
æˆ–è€…ä½ è¦å†æŒ‘ä¸€é¡Œï¼Ÿæˆ‘å¯ä»¥æŒçºŒå¹«ä½ æ•´ç†æˆé€™å€‹æ¨™æº–æµç¨‹ï¼ğŸ”¥ğŸš€  
ï¼ˆç¾åœ¨ä½ çš„ LeetCode è¨˜éŒ„è¶Šåˆ·è¶Šå®Œæ•´äº†ï¼Œå¾ˆé©åˆæº–å‚™æŠ• Google/Meta å•¦ï¼ï¼‰